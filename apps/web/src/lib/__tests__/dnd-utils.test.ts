import type { Priority } from "@repo/db/constants";
import { describe, expect, it } from "vitest";
import type { CardData, NormalizedBoard, StatusValue } from "~/types/board-types";
import {
  calculateDropPosition,
  calculateDropPositionByPriority,
  computeOptimisticCardOrder,
  computeOptimisticCardOrderByPriority,
} from "../dnd-utils";

// Valid fractional indexing positions (generated by generateKeyBetween)
const POS = {
  first: "a0",
  second: "a1",
  third: "a2",
  fourth: "a3",
};

// Helper to create mock card data
function createMockCard(
  id: string,
  position: string,
  status: StatusValue = "todo",
  priority: Priority = "none",
): CardData {
  return {
    id,
    displayId: `RAV-${id}`,
    title: `Card ${id}`,
    description: null,
    boardId: "board-1",
    status,
    priority,
    tags: null,
    position,
    createdAt: new Date(),
    updatedAt: new Date(),
    deletedAt: null,
  };
}

// Helper to create mock board
function createMockBoard(cards: CardData[]): NormalizedBoard {
  const cardsById: Record<string, CardData> = {};
  const cardIdsByStatus: Record<StatusValue, string[]> = {
    backlog: [],
    todo: [],
    in_progress: [],
    review: [],
    done: [],
  };
  const cardIdsByPriority: Record<string, string[]> = {
    none: [],
    low: [],
    medium: [],
    high: [],
    urgent: [],
  };

  for (const card of cards) {
    cardsById[card.id] = card;
    cardIdsByStatus[card.status as StatusValue].push(card.id);
    cardIdsByPriority[card.priority].push(card.id);
  }

  return {
    id: "board-1",
    name: "Test Board",
    slug: "test-board",
    displayIdPrefix: "TES",
    nextCardNumber: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
    cardsById,
    statusOrder: ["backlog", "todo", "in_progress", "review", "done"],
    cardIdsByStatus,
    priorityOrder: ["urgent", "high", "medium", "low", "none"],
    cardIdsByPriority,
  };
}

describe("calculateDropPosition", () => {
  it("calculates position for drop on empty column", () => {
    const board = createMockBoard([]);

    const result = calculateDropPosition(
      board,
      "card-1",
      "todo",
      "todo-column", // column id when empty
      undefined,
    );

    expect(result.newPosition).toBeDefined();
    expect(result.insertIndex).toBe(0);
  });

  it("calculates position for drop at start of column", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "todo"),
    ];
    const board = createMockBoard(cards);

    // Dropping on first card from outside (inserting before)
    const result = calculateDropPosition(
      board,
      "new-card",
      "todo",
      "1",
      board.cardsById["1"],
    );

    // Should generate position before first card
    expect(result.newPosition).toBeDefined();
    expect(result.newPosition < POS.first).toBe(true);
    expect(result.insertIndex).toBe(0);
  });

  it("calculates position for drop between cards", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.third, "todo"),
    ];
    const board = createMockBoard(cards);

    // Dropping card-1 after card-2 (reordering within same column)
    const result = calculateDropPosition(
      board,
      "1", // active card
      "todo",
      "2", // over card
      board.cardsById["2"],
    );

    // Since card-1 (index 0) is being moved after card-2 (index 1), insertAfter is true
    // The new position should be after card-2
    expect(result.newPosition).toBeDefined();
    expect(result.newPosition > POS.third).toBe(true);
  });

  it("calculates position for drop at end of column", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "todo"),
    ];
    const board = createMockBoard(cards);

    // Dropping on empty part of column (no overCard)
    const result = calculateDropPosition(
      board,
      "new-card",
      "todo",
      "todo-column",
      undefined,
    );

    // Should generate position after the last card
    expect(result.newPosition).toBeDefined();
    expect(result.newPosition > POS.second).toBe(true);
    expect(result.insertIndex).toBe(2);
  });
});

describe("calculateDropPositionByPriority", () => {
  it("calculates position for drop in priority group", () => {
    const cards = [
      createMockCard("1", POS.first, "todo", "high"),
      createMockCard("2", POS.second, "todo", "high"),
    ];
    const board = createMockBoard(cards);

    const result = calculateDropPositionByPriority(
      board,
      "new-card",
      "high",
      "high-column",
      undefined,
    );

    expect(result.newPosition).toBeDefined();
    expect(result.newPosition > POS.second).toBe(true);
    expect(result.insertIndex).toBe(2);
  });
});

describe("computeOptimisticCardOrder", () => {
  it("reorders cards within same status column", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "todo"),
      createMockCard("3", POS.third, "todo"),
    ];
    const board = createMockBoard(cards);

    // Move card-1 to position 2 (after card-2)
    const result = computeOptimisticCardOrder(
      board,
      "1",
      "todo",
      "todo",
      2, // insertIndex after removal
    );

    expect(result.todo).toEqual(["2", "1", "3"]);
  });

  it("moves card from one status to another", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "in_progress"),
    ];
    const board = createMockBoard(cards);

    // Move card-1 from todo to in_progress at index 0
    const result = computeOptimisticCardOrder(board, "1", "todo", "in_progress", 0);

    expect(result.todo).toEqual([]);
    expect(result.in_progress).toEqual(["1", "2"]);
  });

  it("moves card to end of target status", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "in_progress"),
      createMockCard("3", POS.third, "in_progress"),
    ];
    const board = createMockBoard(cards);

    // Move card-1 from todo to in_progress at end
    const result = computeOptimisticCardOrder(board, "1", "todo", "in_progress", 2);

    expect(result.todo).toEqual([]);
    expect(result.in_progress).toEqual(["2", "3", "1"]);
  });

  it("handles moving last card from a column", () => {
    const cards = [
      createMockCard("1", POS.first, "todo"),
      createMockCard("2", POS.second, "in_progress"),
    ];
    const board = createMockBoard(cards);

    const result = computeOptimisticCardOrder(board, "1", "todo", "in_progress", 1);

    expect(result.todo).toEqual([]);
    expect(result.in_progress).toEqual(["2", "1"]);
  });
});

describe("computeOptimisticCardOrderByPriority", () => {
  it("reorders cards within same priority group", () => {
    const cards = [
      createMockCard("1", POS.first, "todo", "high"),
      createMockCard("2", POS.second, "todo", "high"),
      createMockCard("3", POS.third, "todo", "high"),
    ];
    const board = createMockBoard(cards);

    // Move card-1 to position 2
    const result = computeOptimisticCardOrderByPriority(board, "1", "high", 2, "high");

    expect(result.high).toEqual(["2", "1", "3"]);
  });

  it("moves card from one priority to another", () => {
    const cards = [
      createMockCard("1", POS.first, "todo", "high"),
      createMockCard("2", POS.second, "todo", "low"),
    ];
    const board = createMockBoard(cards);

    // Move card-1 from high to low
    const result = computeOptimisticCardOrderByPriority(board, "1", "low", 1, "high");

    expect(result.high).toEqual([]);
    expect(result.low).toEqual(["2", "1"]);
  });

  it("handles same group reorder without explicit source", () => {
    const cards = [
      createMockCard("1", POS.first, "todo", "high"),
      createMockCard("2", POS.second, "todo", "high"),
    ];
    const board = createMockBoard(cards);

    // Source defaults to target when not specified
    // Moving card "1" to insertIndex 2 means placing it after the current last item
    // After removing "1" from index 0, we insert at adjusted index 1 (since removed before)
    const result = computeOptimisticCardOrderByPriority(
      board,
      "1",
      "high",
      2, // insert at end
    );

    expect(result.high).toEqual(["2", "1"]);
  });
});
